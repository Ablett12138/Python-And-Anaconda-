#----------- 包 --------------#
import numpy as np


#------------------   创建numpy数组的3种方法   -------------#
a = np.array([1,2,3,4,5],dtype='float32') #指定数组类型
b = np.array(range(1,6),dtype='float32')
#推荐写法
c = np.arange(1,10,6)    #1-10 步长为6
print(a)
print(b)
print(c)
# array的属性：
# • shape：返回一个元组，表示 array的维度 [形状，几行几列] （2， 3）两行三列，（2， 2， 3）两个两行三列
# • ndim：返回一个数字，表示array的维度的数目
# • size：返回一个数字，表示array中所有数据元素的数目
# • dtype：返回array中元素的数据类型

print(a.dtype) # int32或int64
print(type(a)) # <class 'numpy.ndarray'>
print(a.shape) # 返回大小
print(a.ndim)  # 返回维度

#------------------   创建numpy统一数组的方法   -------------#
# 参数：
# shape：整数或者整型元组定义返回数组的形状；可以是一个数（创建一维向量），也可以是一个元组（创建多维向量）
# dtype : 数据类型，可选定义返回数组的类型。
# order : {‘C’, ‘F’}, 可选规定返回数组元素在内存的存储顺序：C（C语言） -rowmajor；F（Fortran）column-major。
# np.ones(shape,dtype=None,order='C')
a=np.ones(3) # 返回 array([1. 1. 1.])
b=np.ones((2,3))
b=np.ones((5,6), dtype='int') # 返回 五行六列



# 参数：
# a：用a的形状和数据类型，来定义返回数组的属性
# dtype ： 数据类型，可选
# order顺序 ： {'C'，'F'，'A'或'K'}，可选,覆盖结果的内存布局。
# subok ： bool，可选。True：使用a的内部数据类型，False：使用a数组的数据类型，默认为True
# 返回：与a相同形状和数据类型的数组，并且数组中的值都为1
c=np.ones_like(a,dtype=float,order='C',subok=True)
print(a)
print(b)
print(c)


# 参数：
# shape：整数或者整型元组定义返回数组的形状；可以是一个数（创建一维向量），也可以是一个元组（创建多维向量）
# dtype : 数据类型，可选定义返回数组的类型。
# order : {‘C’, ‘F’}, 可选规定返回数组元素在内存的存储顺序：C（C语言） -rowmajor；F（Fortran）column-major。
# np.zeros(shape,dtype=None,order='C')
a=np.zeros(10) #返回：[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
b=np.zeros((2,4),dtype='int')
# 返回：与b相同形状和数据类型的数组，并且数组中的值都为0
c=np.zeros_like(b,dtype=float)
print(a)
print(b)
print(c)


# 参数：
# shape：整数或者整型元组定义返回数组的形状；可以是一个数（创建一维向量），也可以是一个元组（创建多维向量）
# fill_value：标量（就是纯数值变量）
# dtype : 数据类型，可选定义返回数组的类型。
# order : {‘C’, ‘F’}, 可选规定返回数组元素在内存的存储顺序：C（C语言） -rowmajor；F（Fortran）column-major。
# np.full(shape,fill_value,dtype=None,order='C')
a=np.full((3,3),520,dtype='float32',order='C')
# 返回：与a相同形状和数据类型的数组，并且数组中的值都为fill_value
b=np.full_like(a,520,dtype='int')
print(b)

#------------------   创建numpy多维数组的方法   -------------#
#----------------------------    随机数组生成    --------------------------#
# np.random.randn(d0,d1,…..,dn)
# 传1个数就是一维， 2个数就是二维， n个数就是n维
a = np.random.randn(2,3)  #一个随机数
print(a)
# 需要四舍五入：
b=np.round(a,2) # 变量a，保留两位小数点
print(b)

#----------------------------    多维数组生成    --------------------------#
#注意：    最后两个数为几行几列（维），倒数第三个数是几个几行几列，以此类推
          # 几个[]就是几维
# 一维数组的定义：当数组中每个元素都只带有一个下标时，称这样的数组为一维数组，一维数组实质上是一组相同类型数据的线性集合。
# 二维数组的定义：二维数组本质上是以数组作为数组元素的数组，即“数组的数组”。
a=np.array([[1,2,3],[4,5,6]])
print(a.size)
print(a.shape) # 返回一个元组，查看矩阵或者数组的维数(有几个数就是几维),就是几乘几的数组
print(a.ndim) # 返回数组维度数目
print(a.size) # 返回数组中所有元素的数目
print(a.dtype) # 返回数组中所有元素的数据类型

# 参数：
# shape：整数或者整型元组定义返回数组的形状；可以是一个数（创建一维向量），也可以是一个元组（创建多维向量）
# dtype : 数据类型，可选定义返回数组的类型。
# order : {‘C’, ‘F’}, 可选规定返回数组元素在内存的存储顺序：C（C语言） -rowmajor；F（Fortran）column-major。
# np.ones(shape,dtype=None,order='C')
print('----------------------  多维数组  ------------------------')
a=np.ones((3,3,4,5),dtype='int',order='C')
print(a)
print(a.dtype) # int32或int64
print(type(a)) # <class 'numpy.ndarray'>
print(a.shape) # 返回大小
print(a.ndim)  # 返回维度

b=np.full_like(a,520,dtype='float32')
print(b)
print(b.dtype) # int32或int64
print(type(b)) # <class 'numpy.ndarray'>
print(b.shape) # 返回大小
print(b.ndim)  # 返回维度

#----------------------------    数组的计算    --------------------------#
# 能变成2行5列，就能变回1行10个元素，想让他变成一维就给它传一个数，这个数必需是这个数组所有
# 值的全部个数。
# a.reshape(1,10) 等于 a.reshape(10)
# 但是如果我不清楚这个数组中有多少个数，但是仍然想转成一维
# a.flatten()
# 作用：将一个多维数组展开变成一个一维数组
# 注意区别：
# shape：返回数组的维度
# reshape:不改变数组的值，修改形状
a = np.arange(10).reshape(2,5) # 变成2行5列
print(a)
b = a.reshape(-1,5) # 变回1行1列
c = a.flatten() # 不清楚对方什么阵型，直接转一维
print(b)
print(c)

# 凡是形状一样的数组，假设数组a和数组b，可以直接用a+b 或 a-b
a = np.arange(10).reshape(2,5)
b = np.random.randn(2,5)
print(a+b)
print(a-b)

# 总结：
# （1）形状一样的数组按对应位置进行计算。
# （2）一维和多维数组是可以计算的，只要它们在某一维度上是一样的形状，仍然是按位置计算。
# 广播的原则:
# 如果两个数组的后缘维度（trailing dimension，即从末尾开始算起的维度）的轴长度相符，或其中的一方的长度为1，则认为它们是广播兼容的。广播会
# 在缺失和（或）长度为1的维度上进行。
# 这句话乃是理解广播的核心。广播主要发生在两种情况，一种是两个数组的维数不相等，但是它们的后缘维度的轴长相符，另外一种是有一方的长度为1。
#--------  维度比相同，除非值为1 ---------# 
a = np.arange(3)
b = np.arange(24).reshape(-1,2,3)
print(a)
print(b)
print(b-a)



#----------------------------    数组的切片    --------------------------#
A=np.arange(0,100,1).reshape(-1,4)
# print(A)
A[0,0] # 取数组A的0行0列，返回值0
A[-1,2] # 取最后一行的第2列
print(A[-1,-1])
A[2] # 取第2行所有的列
A[-1] # 取最后1行
# print(A[-1])
A[0:-1] # 取除了最后1行之外其它所有行
# print(A[0:-1])
A[0:2,2:4] #取0和1行， 2和3列
A[:,2] # 取所有行中的第2列

#----------------------------    数组的布尔索引    --------------------------#
import numpy as np
数组 = np.arange(10)
print(数组)
筛选 = 数组 > 5
print(筛选) # 返加False和True
print(数组[筛选]) # 返回6 7 8 9

# 实例1：把一维数组进行01化处理
# 假设这10个数字，我想让大于5的数字变成1，小于等于5的数字变成0
数组[数组<=5] = 0 # 小于5的重新赋值为0
数组[数组>5] = 1 # 大于5的重新赋值为1
print(数组)
# 实例2：进行自增量的操作，给大于5的加上520
数组[数组<5] += 520
print(数组)


# 1.5 布尔索引
import numpy as np
数组 = np.arange(10)
print(数组)
print("-"*30)
# 条件组合：找出偶数同时小于7的数
条件 = (数组%2==0) & (数组<7)
# 条件组合：找出偶数同时小于7的数
条件1 = (数组%2==0) | (数组<7)

print(条件)
print("-"*30)
print(数组[条件])

#----------------------------    数组的索引    --------------------------#
import numpy as np
数组 = np.arange(36).reshape(9,4)
a    = np.arange(9)
print(数组)
print("*"*15)
print(数组[:,[1,3,0,2]]) # 返回所有行的，第1列，第3列，第0列，第2列

print(a[[1,3,0,2]]) # 返回下标第1,3,0,2处的值


# 实例：获取数组中最大的前N个数字
# 获取数组中最大的前N个数字
import numpy as np
#获取1-99的随机数
数组 = np.random.randint(1,101,10)
print(数组)
# 数组.argsort()会返回排序后的下标
# 取最大值对应的3个下标，因为默认升序，所以要用-3,从倒数第3个到最后一个
下标 = 数组.argsort()[-3:]
print(下标) # 返回的是最大3个数在数组中的下标
# 将下标传给数组
最大 = 数组[下标]
print(f'最大的三个数是{最大}')

#----------------------------    Numpy的轴    --------------------------#
# 最内层一对 [ ] 可以代表一个1维数组
# 加粗的一对 [ ] 里面有3个一维数组，也就是2维数组
# 最外层的一对 [ ]里面有3个2维数组也就是3维数组
# 0轴是行， 1轴是列， 2轴是纵深
# 纵深:数组深度指的是数组嵌套的深度，如[1]数组深度为1，而[[1], [2,3,4], [5,[2,3]], [7], [0,[1,2,3,4],3,5], [1,3], [3,2,4]]数组深度应为3
# 数组的shape维度是（4,3,2），元组的索引为 [ 0,1,2 ]
# 假设维度是（2， 3），元组的索引为[0,1]
# 假设维度是（4，） 元组的索引为[0]
# 可以看到轴编号和shape元组的索引是对等的，所以这个编号可以理解为高维nd.array.shape产生的元组的索引
# 我们知道shape（4,3,2）表示数组的维度，既然shape的索引可以看做轴编号，那么一条轴其实就是一个维度
# 0轴对应的是最高维度3维， 1轴对应2维， 2轴对应的就是最低维度的1维
# 总结：凡是提到轴，先看数组的维度，有几维就有几个轴
数组=np.array([[[1,2],[4,5],[7,8]],[[8,9],[11,12],[14,15]],[[10,11],[13,14],[16,17]],[[19,20],[22,23],[25,26]]])
print(数组)
小数组=np.arange(6).reshape(3,2)

print(数组.shape) # 返回 (4, 3, 2)
print(数组+小数组)

# 数组的维度：（2， 2， 4） 元组索引（下标）： [0,1,2]
# 我们转换它：
# 3维数组的1维（2轴）上是4个一维数组，每个1维数组都有一个由0,1两个轴编号组成的索引 [ 0,0 ] , [ 0,1 ] , [ 1,0 ] , [ 1,1 ]，transpose方法传入的参数是
# 轴编号 (1, 0, 2) ---转置
import numpy as np
数组=np.arange(16).reshape((2, 2, 4))
print(数组)
print("-"*30)
print(数组.shape)
print("-"*30)
b=数组.transpose()
print(b)
c=np.arange(4).reshape (2,2)
print(b-c)

#轴转置
数组=np.arange(24).reshape((2,4,3))

print(数组)
print("-"*30)
print(数组.transpose())
print("-"*30)
print(数组.swapaxes(1,2))